env:
  GH_TOKEN: ${{ github.token }}
  RELEASEURL: "https://github.com/${{ github.repository }}/releases/download"

on:
  pull_request:
    branches:
      - "main"
  push:
    branches:
      - "main"
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch:
    inputs:
      force-rebuild:
        description: "Force rebuild"
        required: true
        default: false
        type: boolean

# Needed to allow creating a release
permissions:
  contents: write

# Prevent multiple workflow runs from racing to ensure that pushes are made
# sequentialy for the main branch. Also cancel in progress workflow runs.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  build:
    name: build
    runs-on: ubuntu-latest
    steps:
      - name: setup-mkosi
        uses: systemd/mkosi@main
      - name: checkout repo
        uses: actions/checkout@main
      - name: Decrypt large secret
        run: ./scripts/decrypt_secrets.sh
        env:
          SECRET_PASSPHRASE: ${{ secrets.SECRET_PASSPHRASE }}
      - name: build
        run: |
          cp $HOME/secrets/mkosi.crt .
          cp $HOME/secrets/mkosi.key .
          chmod 600 ./mkosi.key
          mkosi build --compress-output=yes --dependency=base
      - name: "push main image"
        env:
          PR: ${{ github.event_name == 'pull_request' }}
          FORCE_REBUILD: ${{ inputs.force-rebuild }}
        shell: bash
        run: |
          set -euxo pipefail
          OUTPUTDIR="./mkosi.output"

          # find the first file in the output directory that matches the pattern "SNOW_*.manifest"
          MANIFEST_FILE=$(find "$OUTPUTDIR" -maxdepth 1 -type f -name "SNOW_*.manifest" | head -n 1)
          echo "Found manifest file: $MANIFEST_FILE"

          ARCH=$(jq -r '.config.architecture' "$MANIFEST_FILE")
          VERSION=$(jq -r '.config.version' "$MANIFEST_FILE")
          IMAGE_ID=$(jq -r '.config.name' "$MANIFEST_FILE")
          RELEASE=$(jq -r '.config.release' "$MANIFEST_FILE")
          BASENAME="${IMAGE_ID}_${VERSION}_${ARCH}"
          TAGNAME="${IMAGE_ID}_${VERSION}_${ARCH}"

          find ./mkosi.images/base -type f -exec sha256sum {} \; | sort > ./mkosi.output/inputs
          find ./mkosi.extra/ -type f -exec sha256sum {} \; | sort >> ./mkosi.output/inputs
          sha256sum mkosi.conf >> ./mkosi.output/inputs
          sha256sum mkosi.finalize >> ./mkosi.output/inputs

          cp ./mkosi.output/${BASENAME}.SHA256SUMS ./mkosi.output/SHA256SUMS

          echo "Proceeding to publish new release for: ${TAGNAME}"

          if [[ "${PR}" == "true" ]]; then
            echo "Pull request detected. Skipping release creation for ${TAGNAME}."
            rm -rf  \
              ./${TAGNAME}.raw.zst \
              ./${TAGNAME}.efi \
              ./${TAGNAME}.esp.raw.zst \
              ./${TAGNAME}.usr-x86-64-verity-sig.*.raw.zst \
              ./${TAGNAME}.usr-x86-64-verity.*.raw.zst \
              ./${TAGNAME}.usr-x86-64.*.raw.zst \
              ./inputs \
              ./SHA256SUMS \
              ./notes
            exit 0
          fi

          git config --global --add safe.directory "${PWD}"

          cd "mkosi.output"

          echo "Searching for ${TAGNAME}.raw.zst"
          ls -la .
          if [[ ! -f ./${TAGNAME}.raw.zst ]]; then
            echo "No image built. Skipping."
            exit 0
          fi
          cat ./SHA256SUMS
          echo "Creating new release for: ${TAGNAME}"

          {
          echo "Release:"
          echo "\`\`\`"
          cat ./SHA256SUMS
          echo "\`\`\`"
          echo ""
          echo "Built using input files:"
          echo "\`\`\`"
          cat ./inputs
          echo "\`\`\`"
          } > notes

          gh release delete \
            --cleanup-tag \
            --yes \
            "${TAGNAME}" \
            || true

          gh release create \
            --title "${IMAGE_ID} ${VERSION} for Debian ${RELEASE} (${ARCH})" \
            --notes-file notes \
            "${TAGNAME}" \
            --latest=false \
            ./${TAGNAME}.raw.zst \
            ./${TAGNAME}.efi \
            ./${TAGNAME}.esp.raw.zst \
            ./${TAGNAME}.usr-x86-64-verity-sig.*.raw.zst \
            ./${TAGNAME}.usr-x86-64-verity.*.raw.zst \
            ./${TAGNAME}.usr-x86-64.*.raw.zst \
            ./${TAGNAME}.manifest \
            ./SHA256SUMS \
            ./inputs

          rm -rf  \
            ./${TAGNAME}.raw.zst \
            ./${TAGNAME}.efi \
            ./${TAGNAME}.esp.raw.zst \
            ./${TAGNAME}.usr-x86-64-verity-sig.*.raw.zst \
            ./${TAGNAME}.usr-x86-64-verity.*.raw.zst \
            ./${TAGNAME}.usr-x86-64.*.raw.zst \
            ./${TAGNAME}.manifest \
            ./inputs \
            ./SHA256SUMS \
            ./notes
      - name: "named release for SNOW Linux"
        env:
          PR: ${{ github.event_name == 'pull_request' }}
          FORCE_REBUILD: ${{ inputs.force-rebuild }}
        shell: bash
        run: |
          set -euxo pipefail

          if [[ "${PR}" == "true" ]]; then
            echo "Pull request detected. Skipping release creation."
            exit 0
          fi
          rm -f ./SHA256SUMS*
          gh release list --limit 2000 --json tagName > releases.json

          releases=(
            $(
              cat releases.json \
                | jq --arg OS "SNOW" --raw-output '
                  map(
                    select(
                      (.tagName | startswith($OS))
                      and
                      (.tagName != $OS)
                    )
                  )
                  | .[].tagName
                ' \
                | sort -h
            )
          )

          echo "Looking at releases: ${releases[@]}"
          for rel in ${releases[@]}; do
            echo "Fetching SHA256SUMS for release: ${rel}"
            curl --location --fail --output "SHA256SUMS.${rel}" "${RELEASEURL}/${rel}/SHA256SUMS" || touch "SHA256SUMS.${rel}"
          done
          ls ./SHA256SUMS.* | sort -h | xargs cat > SHA256SUMS
          new="$(cat SHA256SUMS | sha256sum)"

          old=""
          echo "Fetching SHA256SUMS from release: SNOW"
          curl --location --fail --output SHA256SUMS.old "${RELEASEURL}/SNOW/SHA256SUMS" || touch SHA256SUMS.old
          old="$(cat SHA256SUMS.old | sha256sum)"
          if [[ "${new}" == "${old}" ]]; then
            echo "No changes for SNOW since last release. Skipping."
          else
            echo "Creating new release: SNOW"

            {
            echo "Versions available:"
            echo "\`\`\`"
            cat ./SHA256SUMS
            echo "\`\`\`"
            } > notes

            gh release delete \
              --cleanup-tag \
              --yes \
              "SNOW" \
              || true

            gh release create \
              --title "SNOW Linux" \
              --notes-file notes \
              "SNOW" \
              --latest=false \
              ./SHA256SUMS
          fi
      - name: "Maybe publish sysext: sysext-dev"
        env:
          SYSEXT: sysext-dev
          PR: ${{ github.event_name == 'pull_request' }}
          FORCE_REBUILD: ${{ inputs.force-rebuild }}
        shell: bash
        run: |
          set -euxo pipefail

          rm -rf mkosi.output/${SYSEXT}.inputs
          rm -rf mkosi.output/${SYSEXT}.version
          rm -rf mkosi.output/${SYSEXT}.arch
          rm -rf mkosi.output/${SYSEXT}.tagname
          rm -rf mkosi.output/SHA256SUMS

          # since we skipped building the sysexts when building the main image,
          # we need to build the sysext now
          echo "Building sysext: ${SYSEXT}"
          mkosi build --profile=sysext-only --dependency=${SYSEXT}



          # Check if we are asked to force a rebuild
          if [ -n ${FORCE_REBUILD+x} ]; then
              if [[ "${FORCE_REBUILD}" == true ]]; then
                  echo "Building (forced rebuild)"
                    mkosi build --profile=sysext-only --dependency=${SYSEXT}
                  exit 0
              fi
          fi

          # find the first file in the output directory that matches the pattern "sysext-code*.manifest"
          MANIFEST_FILE=$(find ./mkosi.output -maxdepth 1 -type f -name "${SYSEXT}*.manifest" | head -n 1)
          echo "Found manifest file: $MANIFEST_FILE"

          # get the filename without the directory and without the extension
          # this should be "sysext-XXX_<version>_<arch>"
          BASE=$(basename "$MANIFEST_FILE" .manifest)


          # Only release if the inputs changed
          # VERSION_ID is the Debian version ID for the sysext, in numerical format (e.g., "12" for Debian 12)
          # SYSCON is the output format of the sysext, either "confext" or "sysext"
          VERSION_ID=$(cat $MANIFEST_FILE | jq -r '.extension.VERSION_ID')
          SYSCON=$(cat $MANIFEST_FILE | jq -r '.config.output_format')
          # KEYPACKAGE is the name of the key package for this sysext, if any, otherwise "NIL"
          KEYPACKAGE=$(cat $MANIFEST_FILE | jq -r '.config.key_package')
          echo "KEYPACKAGE for ${SYSEXT} is: ${KEYPACKAGE}"
          if [[ "${KEYPACKAGE}" == "NIL" ]]; then
              KEYVERSION="NIL"
          else
              KEYVERSION=$(cat $MANIFEST_FILE | jq -r --arg KEYPACKAGE ${KEYPACKAGE} '.packages[] | select (.name == $KEYPACKAGE) | .version')
          fi
          VERSION=$(cat $MANIFEST_FILE | jq -r '.config.version')
          ARCH=$(cat $MANIFEST_FILE | jq -r '.config.architecture')

          echo "VERSION for ${SYSEXT} is: ${VERSION}"

          find ./mkosi.images/${SYSEXT} -type f -exec sha256sum {} \; | sort > ./mkosi.output/${SYSEXT}.inputs

          new="$(cat ./mkosi.output/${SYSEXT}.inputs)"

          TAGNAME="${SYSEXT}_${VERSION}_${ARCH}"

          echo "Fetching info from existing release: ${TAGNAME}"
          curl --location --fail --output inputs.old  "${RELEASEURL}/${TAGNAME}/${SYSEXT}.inputs"  || touch ${SYSEXT}.inputs.old
          old="$(cat ${SYSEXT}.inputs.old)"

          # only proceed if the inputs changed

          if [[ "${new}" == "${old}" ]]; then
            echo "No changes in inputs since last release. Skipping."
            exit 0
          fi
          echo 1 > ./mkosi.output/${SYSEXT}.release_needed
          echo "Detected changes. Proceeding to publish new sysext for: ${TAGNAME}"
      - name: "Publish sysext if changed"
        env:
          SYSEXT: sysext-dev
          PR: ${{ github.event_name == 'pull_request' }}
          GH_TOKEN: ${{ github.token }}
        if: (github.event_name == 'push' || github.event_name == 'schedule' || github.event_name == 'workflow_dispatch') && github.ref == 'refs/heads/main'
        shell: bash
        run: |
          set -euxo pipefail
          if [[ "${PR}" == "true" ]]; then
            echo "Pull request detected. Skipping release creation."
            exit 0
          fi
          git config --global --add safe.directory "${PWD}"

          cd "mkosi.output"
          ls -la

          release_needed=$(cat ./${SYSEXT}.release_needed || echo "0")
          if [[ "${release_needed}" != "1" ]]; then
            echo "No release needed for ${SYSEXT}. Skipping."
            exit 0
          fi
          # find the first file in the output directory that matches the pattern "sysext-code*.manifest"
          MANIFEST_FILE=$(find . -maxdepth 1 -type f -name "${SYSEXT}*.manifest" | head -n 1)
          echo "Found manifest file: $MANIFEST_FILE"

          # get the filename without the directory and without the extension
          # this should be "sysext-XXX_<version>_<arch>"
          BASE=$(basename "$MANIFEST_FILE" .manifest)
          VERSION_ID=$(cat $MANIFEST_FILE | jq -r '.extension.VERSION_ID')

          SYSCON=$(cat $MANIFEST_FILE | jq -r '.config.output_format')
          # KEYPACKAGE is the name of the key package for this sysext, if any, otherwise "NIL"
          KEYPACKAGE=$(cat $MANIFEST_FILE | jq -r '.config.key_package')
          echo "KEYPACKAGE for ${SYSEXT} is: ${KEYPACKAGE}"
          if [[ "${KEYPACKAGE}" == "NIL" ]]; then
              KEYVERSION="NIL"
          else
              KEYVERSION=$(cat $MANIFEST_FILE | jq -r --arg KEYPACKAGE ${KEYPACKAGE} '.packages[] | select (.name == $KEYPACKAGE) | .version')
          fi
          VERSION=$(cat $MANIFEST_FILE | jq -r '.config.version')
          ARCH=$(cat $MANIFEST_FILE | jq -r '.config.architecture')

          # This is BASE now
          TAGNAME="${SYSEXT}_${VERSION}_${ARCH}"

          if [[ ! -f ./${BASE}.raw ]]; then
            echo "No sysext built. Skipping."
            exit 0
          fi


          # rename the sysext to match the expected naming convention for releases
          mv ./${BASE}.raw ./${TAGNAME}.raw
          echo "Renamed ./${BASE}.raw to ./${TAGNAME}.raw"
          sha256sum ${TAGNAME}.raw > ./SHA256SUMS



          echo "Creating new release for: ${BASE}"

          {
          echo "Release:"
          echo "\`\`\`"
          cat ./SHA256SUMS
          echo "\`\`\`"
          echo ""
          if [[ "${KEYPACKAGE}" != "NIL" ]]; then
              echo "Key package: ${KEYPACKAGE} (version: ${KEYVERSION})"
          else
              echo "No key package for this sysext."
          fi
          echo ""
          echo "Built using input files:"
          echo "\`\`\`"
          cat ./${SYSEXT}.inputs
          echo "\`\`\`"
          } > notes

          gh release delete \
            --cleanup-tag \
            --yes \
            "${TAGNAME}" \
            || true

          gh release create \
            --title "${SYSEXT} ${VERSION} for Debian ${VERSION_ID} (${ARCH})" \
            --notes-file notes \
            "${TAGNAME}" \
            --latest=false \
            ./${TAGNAME}.raw ./SHA256SUMS ./${SYSEXT}.inputs

          rm -rf  \
            ./${TAGNAME}.raw \
            ./${SYSEXT}.inputs \
            ./SHA256SUMS \
            ./notes

      - name: "Maybe publish sysext: sysext-incus"
        env:
          SYSEXT: sysext-incus
          PR: ${{ github.event_name == 'pull_request' }}
          FORCE_REBUILD: ${{ inputs.force-rebuild }}
        shell: bash
        run: |
          set -euxo pipefail

          rm -rf mkosi.output/${SYSEXT}.inputs
          rm -rf mkosi.output/${SYSEXT}.version
          rm -rf mkosi.output/${SYSEXT}.arch
          rm -rf mkosi.output/${SYSEXT}.tagname
          rm -rf mkosi.output/SHA256SUMS

          # since we skipped building the sysexts when building the main image,
          # we need to build the sysext now
          echo "Building sysext: ${SYSEXT}"
          mkosi build --profile=sysext-only --dependency=${SYSEXT}



          # Check if we are asked to force a rebuild
          if [ -n ${FORCE_REBUILD+x} ]; then
              if [[ "${FORCE_REBUILD}" == true ]]; then
                  echo "Building (forced rebuild)"
                    mkosi build --profile=sysext-only --dependency=${SYSEXT}
                  exit 0
              fi
          fi

          # find the first file in the output directory that matches the pattern "sysext-code*.manifest"
          MANIFEST_FILE=$(find ./mkosi.output -maxdepth 1 -type f -name "${SYSEXT}*.manifest" | head -n 1)
          echo "Found manifest file: $MANIFEST_FILE"

          # get the filename without the directory and without the extension
          # this should be "sysext-XXX_<version>_<arch>"
          BASE=$(basename "$MANIFEST_FILE" .manifest)


          # Only release if the inputs changed
          # VERSION_ID is the Debian version ID for the sysext, in numerical format (e.g., "12" for Debian 12)
          # SYSCON is the output format of the sysext, either "confext" or "sysext"
          VERSION_ID=$(cat $MANIFEST_FILE | jq -r '.extension.VERSION_ID')
          SYSCON=$(cat $MANIFEST_FILE | jq -r '.config.output_format')
          # KEYPACKAGE is the name of the key package for this sysext, if any, otherwise "NIL"
          KEYPACKAGE=$(cat $MANIFEST_FILE | jq -r '.config.key_package')
          echo "KEYPACKAGE for ${SYSEXT} is: ${KEYPACKAGE}"
          if [[ "${KEYPACKAGE}" == "NIL" ]]; then
              KEYVERSION="NIL"
          else
              KEYVERSION=$(cat $MANIFEST_FILE | jq -r --arg KEYPACKAGE ${KEYPACKAGE} '.packages[] | select (.name == $KEYPACKAGE) | .version')
          fi
          VERSION=$(cat $MANIFEST_FILE | jq -r '.config.version')
          ARCH=$(cat $MANIFEST_FILE | jq -r '.config.architecture')

          echo "VERSION for ${SYSEXT} is: ${VERSION}"

          find ./mkosi.images/${SYSEXT} -type f -exec sha256sum {} \; | sort > ./mkosi.output/${SYSEXT}.inputs

          new="$(cat ./mkosi.output/${SYSEXT}.inputs)"

          TAGNAME="${SYSEXT}_${VERSION}_${ARCH}"

          echo "Fetching info from existing release: ${TAGNAME}"
          curl --location --fail --output inputs.old  "${RELEASEURL}/${TAGNAME}/${SYSEXT}.inputs"  || touch ${SYSEXT}.inputs.old
          old="$(cat ${SYSEXT}.inputs.old)"

          # only proceed if the inputs changed

          if [[ "${new}" == "${old}" ]]; then
            echo "No changes in inputs since last release. Skipping."
            exit 0
          fi
          echo 1 > ./mkosi.output/${SYSEXT}.release_needed
          echo "Detected changes. Proceeding to publish new sysext for: ${TAGNAME}"
      - name: "Publish sysext if changed"
        env:
          SYSEXT: sysext-incus
          PR: ${{ github.event_name == 'pull_request' }}
          GH_TOKEN: ${{ github.token }}
        if: (github.event_name == 'push' || github.event_name == 'schedule' || github.event_name == 'workflow_dispatch') && github.ref == 'refs/heads/main'
        shell: bash
        run: |
          set -euxo pipefail
          if [[ "${PR}" == "true" ]]; then
            echo "Pull request detected. Skipping release creation."
            exit 0
          fi
          git config --global --add safe.directory "${PWD}"

          cd "mkosi.output"
          ls -la

          release_needed=$(cat ./${SYSEXT}.release_needed || echo "0")
          if [[ "${release_needed}" != "1" ]]; then
            echo "No release needed for ${SYSEXT}. Skipping."
            exit 0
          fi
          # find the first file in the output directory that matches the pattern "sysext-code*.manifest"
          MANIFEST_FILE=$(find . -maxdepth 1 -type f -name "${SYSEXT}*.manifest" | head -n 1)
          echo "Found manifest file: $MANIFEST_FILE"

          # get the filename without the directory and without the extension
          # this should be "sysext-XXX_<version>_<arch>"
          BASE=$(basename "$MANIFEST_FILE" .manifest)
          VERSION_ID=$(cat $MANIFEST_FILE | jq -r '.extension.VERSION_ID')

          SYSCON=$(cat $MANIFEST_FILE | jq -r '.config.output_format')
          # KEYPACKAGE is the name of the key package for this sysext, if any, otherwise "NIL"
          KEYPACKAGE=$(cat $MANIFEST_FILE | jq -r '.config.key_package')
          echo "KEYPACKAGE for ${SYSEXT} is: ${KEYPACKAGE}"
          if [[ "${KEYPACKAGE}" == "NIL" ]]; then
              KEYVERSION="NIL"
          else
              KEYVERSION=$(cat $MANIFEST_FILE | jq -r --arg KEYPACKAGE ${KEYPACKAGE} '.packages[] | select (.name == $KEYPACKAGE) | .version')
          fi
          VERSION=$(cat $MANIFEST_FILE | jq -r '.config.version')
          ARCH=$(cat $MANIFEST_FILE | jq -r '.config.architecture')

          # This is BASE now
          TAGNAME="${SYSEXT}_${VERSION}_${ARCH}"

          if [[ ! -f ./${BASE}.raw ]]; then
            echo "No sysext built. Skipping."
            exit 0
          fi


          # rename the sysext to match the expected naming convention for releases
          mv ./${BASE}.raw ./${TAGNAME}.raw
          echo "Renamed ./${BASE}.raw to ./${TAGNAME}.raw"
          sha256sum ${TAGNAME}.raw > ./SHA256SUMS



          echo "Creating new release for: ${BASE}"

          {
          echo "Release:"
          echo "\`\`\`"
          cat ./SHA256SUMS
          echo "\`\`\`"
          echo ""
          if [[ "${KEYPACKAGE}" != "NIL" ]]; then
              echo "Key package: ${KEYPACKAGE} (version: ${KEYVERSION})"
          else
              echo "No key package for this sysext."
          fi
          echo ""
          echo "Built using input files:"
          echo "\`\`\`"
          cat ./${SYSEXT}.inputs
          echo "\`\`\`"
          } > notes

          gh release delete \
            --cleanup-tag \
            --yes \
            "${TAGNAME}" \
            || true

          gh release create \
            --title "${SYSEXT} ${VERSION} for Debian ${VERSION_ID} (${ARCH})" \
            --notes-file notes \
            "${TAGNAME}" \
            --latest=false \
            ./${TAGNAME}.raw ./SHA256SUMS ./${SYSEXT}.inputs

          rm -rf  \
            ./${TAGNAME}.raw \
            ./${SYSEXT}.inputs \
            ./SHA256SUMS \
            ./notes

      - name: "named release for extensions"
        env:
          PR: ${{ github.event_name == 'pull_request' }}
          FORCE_REBUILD: ${{ inputs.force-rebuild }}
          SYSEXTS: 'sysext-dev;sysext-incus;'
        shell: bash
        run: |
          set -euxo pipefail


          if [[ "${PR}" == "true" ]]; then
            echo "Pull request detected. Skipping named release creation."
            exit 0
          fi
          echo "Sleeping to wait for previous releases to be ready..."
          sleep 180 # wait for previous releases to be ready
          gh release list --limit 2000 --json tagName > releases.json

          for sysext in $(echo ${SYSEXTS} | tr ';' ' '); do
            rm -f ./SHA256SUMS* ./*.transfer

            releases=(
              $(
                cat releases.json \
                  | jq --arg SYSEXT "${sysext}" --raw-output '
                    map(
                      select(
                        (.tagName | startswith($SYSEXT))
                        and
                        (.tagName != $SYSEXT)
                      )
                    )
                    | .[].tagName
                  ' \
                  | sort -h
              )
            )
            echo "Looking at releases: ${releases[@]}"
            for rel in ${releases[@]}; do
              echo "Fetching SHA256SUMS for release: ${rel}"
              curl --location --fail --output "SHA256SUMS.${rel}" "${RELEASEURL}/${rel}/SHA256SUMS" || touch "SHA256SUMS.${rel}"
            done
            ls ./SHA256SUMS.* | sort -h | xargs cat > SHA256SUMS
            new="$(cat SHA256SUMS | sha256sum)"

            old=""
            echo "Fetching SHA256SUMS from release: ${sysext}"
            curl --location --fail --output SHA256SUMS.old "${RELEASEURL}/${sysext}/SHA256SUMS" || touch SHA256SUMS.old
            old="$(cat SHA256SUMS.old | sha256sum)"

            if [[ "${new}" == "${old}" ]]; then
              echo "No changes for ${sysext} since last release. Skipping."
            else
              echo "Creating new release: ${sysext}"

              sed "s/%%SYSEXT%%/${sysext}/g" .workflow-templates/systemd-sysupdate.transfer > ${sysext}.transfer

              {
              echo "Versions available:"
              echo "\`\`\`"
              cat ./SHA256SUMS
              echo "\`\`\`"
              } > notes

              gh release delete \
                --cleanup-tag \
                --yes \
                "${sysext}" \
                || true

              gh release create \
                --title "${sysext} systemd system extensions for SNOW" \
                --notes-file notes \
                "${sysext}" \
                --latest=false \
                ./SHA256SUMS ./${sysext}.transfer
            fi
          done
      - name: "gather"
        env:
          PR: ${{ github.event_name == 'pull_request' }}
          FORCE_REBUILD: ${{ inputs.force-rebuild }}
          SYSEXTS: 'sysext-dev;sysext-incus;'
        shell: bash
        run: |
          set -euxo pipefail

          if [[ "${PR}" == "true" ]]; then
            echo "Pull request detected. Skipping release creation."
            exit 0
          fi
          echo "Sleeping to wait for previous releases to be ready..."
          sleep 180 # wait for previous releases to be ready

          rm -f ./SHA256SUMS* ./*.conf

          # Gather Sysext named releases and their SHA256SUMS files
          for sysext in $(echo ${SYSEXTS} | tr ';' ' '); do
              curl --location --fail --output "SHA256SUMS.${sysext}" "${RELEASEURL}/${sysext}/SHA256SUMS" || touch "SHA256SUMS.${sysext}"
          done
          curl --location --fail --output "SHA256SUMS.SNOW" "${RELEASEURL}/SNOW/SHA256SUMS" || touch "SHA256SUMS.SNOW"

          ls ./SHA256SUMS.* | sort -h | xargs cat > SHA256SUMS

          {
          echo "Versions available:"
          echo "\`\`\`"
          cat ./SHA256SUMS
          echo "\`\`\`"
          } > notes

          gh release delete \
            --cleanup-tag \
            --yes \
            latest \
            || true

          gh release create \
            --title "SNOW Linux Releases" \
            --notes-file notes \
            latest \
            --latest=true \
            ./SHA256SUMS
